using CommandLine;
using SkiaSharp;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Globalization;

namespace GcodeCreator
{

    class GcodeCreator
    {
        static double
            eD = 0.4,
            fD = 1.75,
            speed = 3600,
            speed_outer = 3600,
            speed_inner = 3600,
            layerHeight;


        public static void Main(string[] args)
        {
            var usCulture = new CultureInfo("en-US");
            Thread.CurrentThread.CurrentCulture = usCulture;
            Thread.CurrentThread.CurrentUICulture = usCulture;

            CommandLine.Parser.Default.ParseArguments<Options>(args)
                .WithParsed(RunOptions)
                .WithNotParsed(HandleParseError);
        }


        static void RunOptions(Options opts)
        {
            layerHeight = opts.layerHeight;
            string folderPath = opts.SavedFolderPath;
            string slicesDescription = File.ReadAllText(Path.Combine(folderPath, "conturs.descriptions"));

            List<List<SKPoint[]>> slices = new List<List<SKPoint[]>>();
            List<List<int[]>> intendStatuses = new List<List<int[]>>();
            string conturFormat = "";

            var gcodeWriter = new StreamWriter(Path.Combine(folderPath, "settings.gcode"));

            string gcodeData_1 =
$@"; G-Code generated by SlicerSolution 2.0.0
; {DateTime.Now}
; Settings Summary
;   applyToModels,{opts.modelName}
;   profileName,DPL
;   baseProfile,Default
;   printMaterial,PLA
;   printQuality,Medium
;   printExtruders,
;   extruderName,Extruder 1
;   extruderToolheadNumber,0
;   extruderDiameter,0.4
;   extruderAutoWidth,1
;   extruderWidth,0.48
;   extrusionMultiplier,0.98
;   extruderUseRetract,1
;   extruderRetractionDistance,2
;   extruderExtraRestartDistance,0
;   extruderRetractionZLift,0
;   extruderRetractionSpeed,2000
;   extruderUseCoasting,0
;   extruderCoastingDistance,0.2
;   extruderUseWipe,0
;   extruderWipeDistance,5
;   primaryExtruder,0
;   layerHeight,{opts.layerHeight}
;   topSolidLayers,{opts.topSolidLayers}
;   bottomSolidLayers,{opts.bottomSolidLayers}
;   perimeterOutlines,{opts.perimiterOutlines}
;   printPerimetersInsideOut,1
;   startPointOption,1
;   startPointOriginX,0
;   startPointOriginY,0
;   sequentialIslands,1
;   spiralVaseMode,0
;   firstLayerHeightPercentage,100
;   firstLayerWidthPercentage,100
;   firstLayerUnderspeed,0.5
;   useRaft,0
;   raftExtruder,0
;   raftTopLayers,2
;   raftBaseLayers,1
;   raftOffset,3
;   raftSeparationDistance,0.14
;   raftTopInfill,80
;   aboveRaftSpeedMultiplier,0.3
;   useSkirt,1
;   skirtExtruder,0
;   skirtLayers,1
;   skirtOutlines,5
;   skirtOffset,0.1
;   usePrimePillar,0
;   primePillarExtruder,999
;   primePillarWidth,12
;   primePillarLocation,7
;   primePillarSpeedMultiplier,1
;   useOozeShield,0
;   oozeShieldExtruder,999
;   oozeShieldOffset,2
;   oozeShieldOutlines,1
;   oozeShieldSidewallShape,1
;   oozeShieldSidewallAngle,30
;   oozeShieldSpeedMultiplier,1
;   infillExtruder,0
;   internalInfillPattern,Rectilinear
;   externalInfillPattern,Rectilinear
;   infillPercentage,30
;   outlineOverlapPercentage,15
;   infillExtrusionWidthPercentage,100
;   minInfillLength,5
;   infillLayerInterval,1
;   internalInfillAngles,45,-45
;   overlapInternalInfillAngles,0
;   externalInfillAngles,45,-45
;   generateSupport,0
;   supportExtruder,0
;   supportInfillPercentage,25
;   supportExtraInflation,0.2
;   supportBaseLayers,0
;   denseSupportExtruder,0
;   denseSupportLayers,3
;   denseSupportInfillPercentage,75
;   supportLayerInterval,1
;   supportHorizontalPartOffset,0.45
;   supportUpperSeparationLayers,1
;   supportLowerSeparationLayers,1
;   supportType,0
;   supportGridSpacing,2
;   maxOverhangAngle,45
;   supportAngles,0
;   temperatureName,Extruder 1,Hot bed
;   temperatureNumber,0,0
;   temperatureSetpointCount,1,1
;   temperatureSetpointLayers,1,1
;   temperatureSetpointTemperatures,{opts.temperatureSetpointTemperatures}
;   temperatureStabilizeAtStartup,1,1
;   temperatureHeatedBed,0,1
;   fanLayers,1,2
;   fanSpeeds,0,15
;   blipFanToFullPower,0
;   adjustSpeedForCooling,1
;   minSpeedLayerTime,15
;   minCoolingSpeedSlowdown,20
;   increaseFanForCooling,0
;   minFanLayerTime,45
;   maxCoolingFanSpeed,100
;   increaseFanForBridging,0
;   bridgingFanSpeed,100
;   use5D,1
;   relativeEdistances,0
;   allowEaxisZeroing,1
;   independentExtruderAxes,0
;   includeM10123,0
;   stickySupport,1
;   applyToolheadOffsets,0
;   gcodeXoffset,0
;   gcodeYoffset,0
;   gcodeZoffset,0
;   overrideMachineDefinition,1
;   machineTypeOverride,0
;   strokeXoverride,240
;   strokeYoverride,270
;   strokeZoverride,250
;   originOffsetXoverride,0
;   originOffsetYoverride,0
;   originOffsetZoverride,0
;   homeXdirOverride,-1
;   homeYdirOverride,-1
;   homeZdirOverride,-1
;   flipXoverride,1
;   flipYoverride,-1
;   flipZoverride,1
;   toolheadOffsets,0,0|0,0|0,0|0,0|0,0|0,0
;   overrideFirmwareConfiguration,1
;   firmwareTypeOverride,RepRap (Marlin/Repetier/Sprinter)
;   GPXconfigOverride,r2
;   baudRateOverride,115200
;   overridePrinterModels,0
;   printerModelsOverride
;   startingGcode,G28 ; home all axes
;   layerChangeGcode,
;   retractionGcode,
;   toolChangeGcode,
;   endingGcode,M104 S0 ; turn off extruder,M140 S0 ; turn off bed,M84 ; disable motors,G28 ; home all axes
;   exportFileFormat,gcode
;   celebration,0
;   celebrationSong,Star Wars
;   postProcessing,
;   defaultSpeed,3000
;   outlineUnderspeed,0.5
;   solidInfillUnderspeed,0.8
;   supportUnderspeed,0.8
;   rapidXYspeed,3800
;   rapidZspeed,1600
;   minBridgingArea,50
;   bridgingExtraInflation,0
;   bridgingExtrusionMultiplier,1
;   bridgingSpeedMultiplier,1
;   useFixedBridgingAngle,0
;   fixedBridgingAngle,0
;   applyBridgingToPerimeters,0
;   filamentDiameters,1.75|1.75|1.75|1.75|1.75|1.75
;   filamentPricesPerKg,46|46|46|46|46|46
;   filamentDensities,1.25|1.25|1.25|1.25|1.25|1.25
;   useMinPrintHeight,0
;   minPrintHeight,0
;   useMaxPrintHeight,0
;   maxPrintHeight,0
;   useDiaphragm,0
;   diaphragmLayerInterval,20
;   robustSlicing,1
;   mergeAllIntoSolid,0
;   onlyRetractWhenCrossingOutline,1
;   retractBetweenLayers,1
;   useRetractionMinTravel,0
;   retractionMinTravel,3
;   retractWhileWiping,0
;   onlyWipeOutlines,1
;   avoidCrossingOutline,0
;   maxMovementDetourFactor,3
;   toolChangeRetractionDistance,12
;   toolChangeExtraRestartDistance,-0.5
;   toolChangeRetractionSpeed,600
;   externalThinWallType,0
;   internalThinWallType,2
;   thinWallAllowedOverlapPercentage,10
;   singleExtrusionMinLength,1
;   singleExtrusionMinPrintingWidthPercentage,50
;   singleExtrusionMaxPrintingWidthPercentage,200
;   singleExtrusionEndpointExtension,0.2
;   horizontalSizeCompensation,0
G90
M82
M106 S0
M140 {opts.M140}
M190 {opts.M190}
M104 {opts.M104}
M109 {opts.M109}
G28
";
            gcodeWriter.WriteLine(gcodeData_1);

            using (var descFile = new StreamReader(Path.Combine(folderPath, "conturs.descriptions")))
            {
                string line;
                List<SKPoint[]> curSlice;
                List<SKPoint> curContur = new List<SKPoint>();
                float scaleKoefficient = opts.scaleKoefficient;
                float x1 = 0, y1 = 0, x2 = 0, y2 = 0;
                double z = 0;
                int sliceCount = -1;

                while (!descFile.EndOfStream)
                {
                    line = descFile.ReadLine();

                    if (line == "DescriptionBegin")
                        continue;
                    else if (line == "DescriptionEnd")
                        break;
                    else if (line == "SliceBegin")
                    {
                        curSlice = new List<SKPoint[]>();
                        slices.Add(curSlice);
                        intendStatuses.Add(new List<int[]>());

                        while ((line = descFile.ReadLine()) != "SliceEnd")
                        {
                            if (line == "ConturBegin")
                            {
                                string[] intendStatusPair = descFile.ReadLine().Split(',');
                                intendStatuses.Last().Add(new int[]
                                {
                                    int.Parse(intendStatusPair[0]),
                                    int.Parse(intendStatusPair[1])
                                });

                                curContur.Clear();

                                while ((line = descFile.ReadLine()) != "ConturEnd")
                                {
                                    string[] coords = line.Split(' ');
                                    x1 = float.Parse(coords[0]);
                                    y1 = float.Parse(coords[1]);

                                    curContur.Add(new SKPoint(
                                        x1,
                                        y1 
                                    ));
                                };

                                curSlice.Add(curContur.ToArray());
                                conturFormat = "";
                            }
                        }
                    }
                    else
                        continue;
                }


                x1 = 0;
                y1 = 0;
                x2 = 0;
                y2 = 0;
                z = 0;
                sliceCount = -1;

                foreach (var s in slices)
                {
                    z += layerHeight;
                    sliceCount += 1;

                    AddLine(ref conturFormat, $"; layer {sliceCount}, Z = {z}");
                    AddLine(ref conturFormat, $"G1 Z{z:f3} F{speed}");
                    foreach (var c in s)
                    {
                        AddLine(ref conturFormat, $"G92 E{0:f4}");

                        double E = 0;
                        for (int i = 1; i < c.Length; i++)
                        {
                            x1 = c[i - 1].X;
                            y1 = c[i - 1].Y;
                            x2 = c[i].X;
                            y2 = c[i].Y;

                            E += dE(x1, y1, x2, y2);

                            AddLine(ref conturFormat, $"G1 X{x1:f3} Y{y1:f3} E{E:f4}"); 
                        }
                        
                        gcodeWriter.WriteLine(conturFormat);
                        conturFormat = "";
                    }
                }

                float
                    minX = float.MaxValue,
                    minY = float.MaxValue,
                    maxX = float.MinValue,
                    maxY = float.MinValue;

                for (int k = 0; k < slices.Count; k++)
                    for (int l = 0; l < slices[k].Count; l++)
                    {
                        minX = Math.Min(minX, slices[k][l].Min(e => e.X));
                        minY = Math.Min(minY, slices[k][l].Min(e => e.Y));
                        maxX = Math.Max(maxX, slices[k][l].Max(e => e.X));
                        maxY = Math.Max(maxY, slices[k][l].Max(e => e.Y));
                    }

                if (speed_outer / 60 > (maxX - minX) / 0.5f)
                {
                    speed_outer = ((maxX - minX) / 0.5f) * 60;
                }
                if (speed_outer / 60 > (maxY - minY) / 0.5f)
                {
                    speed_outer = ((maxY - minY) / 0.5f) * 60;
                }
                speed_inner = speed_outer * 0.75f;

                int
                    windowW = 1024,
                    windowH = 768;

                float
                    shiftX = windowW / 2.0f - (maxX - minX) / 2.0f - minX, 
                    shiftY = windowH / 2.0f - (maxY - minY) / 2.0f - minY; 

                if (opts.onlySettings != 1) { 
                    Drawer drawer = new Drawer(windowW, windowH, shiftX, shiftY, folderPath);
                    for (int k = 0; k < slices.Count; k++)
                        drawer.DrawSlice(slices[k], intendStatuses[k], k);
                }

            }

            string gcodeData_2 =
$@"
M104,0
M140,0
";

            gcodeWriter.Write(gcodeData_2);
            gcodeWriter.Close();
        }


        static double dE(double x1, double y1, double x2, double y2)
        {
            double length = Math.Sqrt(Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));

            return 4 * layerHeight * eD * length / (Math.PI * fD * fD);
        }

        static void HandleParseError(IEnumerable<Error> errs)
        {
            //handle errors
        }

        public static void AddLine(ref string source, string input)
        {
            source += input + "\n";
        }

    }
}